@startuml

interface ModelInterface {
    + boolean shuffleDeck(int)
    + int drawFromDeck(int)
    + boolean selectInitialCardSide(string, boolean)
    + boolean assignColoursToPlayers()
    + ArrayList<int> getStartingHand(string)
    + ArrayList<int> getCommonObjective()
    + ArrayList<int> getSecretObjective()    
    + boolean selectSecretObjective(string, int)
    
    + boolean startPlay()
    + boolean placeCard(int, int, int, boolean)
    + MatchStatus nextPlayer()
    + boolean computeFinalPoints()
    + string getWinner()
    + boolean endMatch()

    + boolean addPlayer(string)
    + boolean deletePlayer(string)
    + boolean startPreparationPhase()
    + boolean cancelMatch()

}
note left of ModelInterface: "startPlay() select random first player"

enum MatchStatus {
    FAIL
    SUCCESS
    LAST_TURN
    END
}

Match <|-- MatchStatus

class Field {
    - fieldCards : ArrayList<CardPosition>
    - activeRes : int[7]
    + boolean placeCardInField(Card, int, int, boolean)
    + Card getCardFromPosition(int, int)
    + boolean avaliableSpace(int, int)
}

Player <|-- Field

class CardPlaced {
    - placedCard : Card
    - x : int
    - y : int
    - isUp : boolean
    + Card getCard()
    + int getX()
    + int getY()
    + boolean getIsUp()
}

Field *-- CardPlaced

class Player {
    - nickname : string
    - gameField : Field
    - secretObjective : Card
    - colour : Colour
    - points : int
    - hand : ArrayList<Card>
    + string getNickname()
    + boolean initializeGameField()
    + Field getField()
    + int receiveSecretObjective(Card[], int)
    + Card getSecretObjective()
    + Colour getColour()
    + int getPoints()
    + boolean setPoints(int)
    + boolean putCardInHand(Card)
    + ArrayList<Card> getHand()
    + boolean performMove(Card, int, int, boolean)
    + boolean updatePointsForObjectives(Card[])
    + int calculatePoints(Card, int, int)
}

Match *-- Player

class Match {
    - starterCardsDeck : Deck
    - objectiveCardsDeck : Deck
    - secretObjectiveCardsDeck : Deck
    - resourceCardsDeck : Deck
    - goldCardsDeck : Deck
    - currentResourceCards : Card[2]
    - currentGoldCards : Card[2]
    - commonObjectives : Card[2]
    - players : ArrayList<Player>
    - currentPlayerID : string
    - isGameTerminating : boolean
    - isLastTurn : boolean
    - currentTurnNumber : int
    + boolean shuffleDeck(int)
    + Card drawFromDeck(int)
    + Card drawFromCurrentResourceCards(int)
    + Card drawFromCurrentGoldCards(int)
    + Card[2] getCommonObjective()
    + boolean addPlayer(string)
    + boolean deletePlayer(string)
    + Colour pickRandomColour()
    + Player getPlayer(string)
    + boolean updateCurrentPlayer()
    + boolean checkIfGameIsTerminating()
    + boolean setGameIsTerminating()
    + boolean checkIfTurnIsLast()
    + boolean setTurnIsLast()
    + int getCurrentTurnNumber()
    + boolean increaseCurrentTurnNumber()
}

class Deck {
    - cards : ArrayList<Card>
    + Card draw()
    + boolean shuffle()
}

Match <|-- Deck

class DecksFromDisk {
    + ArrayList<Card> createResourcesDeck()
    + ArrayList<Card> createGoldDeck()
    + ArrayList<Card> createObjectiveCardsDeck()
    + ArrayList<Card> createStartCardsDeck()
}

Match <|-- DecksFromDisk

enum Colour {
    Red
    Green
    Black
    Blue
    Yellow
}

Player <|-- Colour
Match <|-- Colour

class Card {
    - id : int
    - value : int
    - validBack : boolean
    - pointStrategy : PointStrategy
}

Player <|-- Card
Match <|-- Card
Field <|-- Card

class NonObjectiveCard extends Card {
    - topLeft : CornerType
    - topRight : CornerType
    - bottomLeft : CornerType
    - bottomRight : CornerType
    - topLeftBack : CornerType
    - topRightBack : CornerType
    - bottomLeftBack : CornerType
    - bottomRightBack : CornerType
    - permRes : int[4]
    - permResCount : int
    - conditionCount : int[4]
}

enum CornerType {
    Plant
    Fungi
    Animal
    Insect
    Quill
    Inkwell
    Manuscript
    Empty
    NonCoverable
}

NonObjectiveCard <|-- CornerType

abstract class PointStrategy {
    + int calculateOccurences(Field, int, int)
}

Card <|-- PointStrategy
Player <|-- PointStrategy

class AnglesCovered extends PointStrategy {
    + int calculateOccurences(Field, int, int)
}

class CountResource extends PointStrategy {
    - type : ObjectType
    - count : int
    + int calculateOccurences(Field, int, int)
}

class Diagonals extends PointStrategy {
    - type : ObjectType
    - leftToRight : int
    + int calculateOccurences(Field, int, int)
}

class AllSpecial extends PointStrategy {
    + int calculateOccurences(Field, int, int)
}

class LConfigurationOne extends PointStrategy {
    + int calculateOccurences(Field, int, int)
}

class LConfigurationTwo extends PointStrategy {
    + int calculateOccurences(Field, int, int)
}

class LConfigurationThree extends PointStrategy {
    + int calculateOccurences(Field, int, int)
}

class LConfigurationFour extends PointStrategy {
    + int calculateOccurences(Field, int, int)
}

enum ObjectType {
    Plant
    Fungi
    Animal
    Insect
    Quill
    Inkwell
    Manuscript
}

CountResource <|-- ObjectType
Diagonals <|-- ObjectType

@enduml